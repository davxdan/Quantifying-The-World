# & mac != "00:0f:a3:39:dd:cd",
layout = c(2,3))
locCounts = t(locCounts)
plot(locCounts, type = "n", xlab = "", ylab = "")
text(locCounts, labels = locCounts[,3], cex = .8, srt = 45)
bwplot(signal ~ factor(angle) | mac, data = offline,
subset = posX == 2 & posY == 12
#& mac != "00:0f:a3:39:dd:cd",
,layout = c(2,3))
bwplot(signal ~ factor(angle) | mac, data = offline,
subset = posX == 2 & posY == 12
#& mac != "00:0f:a3:39:dd:cd",
,layout = c(2,3))
bwplot(signal ~ factor(angle) | mac, data = offline,
subset = posX == 2 & posY == 12
#& mac != "00:0f:a3:39:dd:cd",
& mac != "00:0f:a3:39:e1:c0",
layout = c(2,3))
bwplot(signal ~ factor(angle) | mac, data = offline,
subset = posX == 2 & posY == 12
& mac != "00:0f:a3:39:dd:cd",
#& mac != "00:0f:a3:39:e1:c0",
layout = c(2,3))
bwplot(signal ~ factor(angle) | mac, data = offline,
subset = posX == 2 & posY == 12
#& mac != "00:0f:a3:39:dd:cd",
& mac != "00:0f:a3:39:e1:c0",
layout = c(2,3))
summary(offline$signal)
densityplot( ~ signal | mac + factor(angle), data = offline, subset = posX == 24 & posY == 4 & mac != "00:0f:a3:39:dd:cd", bw = 0.5, plot.points = FALSE)
densityplot( ~ signal | mac + factor(angle), data = offline, subset = posX == 24 & posY == 4 , bw = 0.5, plot.points = FALSE)
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac != "00:0f:a3:39:dd:cd",
xlab = "Mean Signal", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
xlab = "Mean Signal", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac != "00:0f:a3:39:dd:cd",
xlab = "Mean Signal", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
xlab = "Mean Signal", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac !="00:0f:a3:39:e1:c0"
xlab = "Mean Signal", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac !="00:0f:a3:39:e1:c0",
xlab = "Mean Signal", ylab = "SD Signal")
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac != "00:0f:a3:39:dd:cd",
xlab = "Mean Signal", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac !="00:0f:a3:39:e1:c0",
xlab = "Mean Signal", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac != "00:0f:a3:39:dd:cd",
xlab = "Mean Signal without cd ", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
xlab = "Mean Signal Keep co and cd ", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac != "00:0f:a3:39:dd:cd",
xlab = "Mean Signal without cd ", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac !="00:0f:a3:39:e1:c0",
xlab = "Mean Signal without c0", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
xlab = "Mean Signal Keep co and cd ", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac != "00:0f:a3:39:dd:cd",
xlab = "Mean Signal without cd ", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac !="00:0f:a3:39:e1:c0",
xlab = "Mean Signal without c0", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
xlab = "Mean Signal Keep co and cd ", ylab = "SD Signal")
with(offlineSummary,
smoothScatter((avgSignal - medSignal) ~ num,
xlab = "Number of Observations",
ylab = "mean - median"))
abline(h = 0, col = "#984ea3", lwd = 2)
lo.obj =
with(offlineSummary,
loess(diff ~ num,
data = data.frame(diff = (avgSignal - medSignal),
num = num)))
lo.obj.pr = predict(lo.obj, newdata = data.frame(num = (70:120)))
lines(x = 70:120, y = lo.obj.pr, col = "#4daf4a", lwd = 2)
oneAPAngle = subset(offline, mac == subMacs[5] & angle == 0)
oneAPAngle = subset(offlineSummary, mac == subMacs[5] & angle == 0)
surfaceSS = function(data, mac, angle = 45) {
require(fields)
oneAPAngle = data[ data$mac == mac & data$angle == angle, ]
smoothSS = Tps(oneAPAngle[, c("posX","posY")],
oneAPAngle$avgSignal)
vizSmooth = predictSurface(smoothSS)
plot.surface(vizSmooth, type = "C",
xlab = "", ylab = "", xaxt = "n", yaxt = "n")
points(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5)
}
mapply(surfaceSS, mac = subMacs[ rep(c(5, 1), each = 2) ],
angle = rep(c(0, 135), 2),
data = list(data = offlineSummary))
parCur = par(mfrow = c(2,2), mar = rep(1, 4))
par(parCur)
offlineSummary = subset(offlineSummary, mac != subMacs[2])
submavs
submacs
lo.obj.pr = predict(lo.obj, newdata = data.frame(num = (70:120)))
lines(x = 70:120, y = lo.obj.pr, col = "#4daf4a", lwd = 2)
oneAPAngle = subset(offline, mac == subMacs[5] & angle == 0)
oneAPAngle = subset(offlineSummary, mac == subMacs[5] & angle == 0)
subMacs
surfaceSS = function(data, mac, angle = 45) {
require(fields)
oneAPAngle = data[ data$mac == mac & data$angle == angle, ]
smoothSS = Tps(oneAPAngle[, c("posX","posY")],
oneAPAngle$avgSignal)
vizSmooth = predictSurface(smoothSS)
plot.surface(vizSmooth, type = "C",
xlab = "", ylab = "", xaxt = "n", yaxt = "n")
points(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5)
}
mapply(surfaceSS, mac = subMacs[ rep(c(5, 1), each = 2) ],
angle = rep(c(0, 135), 2),
data = list(data = offlineSummary))
parCur = par(mfrow = c(2,2), mar = rep(1, 4))
par(parCur)
subMacs
offlineSummary = subset(offlineSummary)
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs[ -2 ], c("x", "y") ))
View(AP)
offlineSummary = subset(offlineSummary, mac != subMacs[2])
View(offlineSummary)
library(fields)
library(lattice)
##################Data Processing###################
setwd('C:/Users/danie/Documents/GitHub/Quantifying-The-World/Case Study 1')
txt = readLines("offline.final.trace.txt")
processLine =
function(x)
{
tokens = strsplit(x, "[;=,]")[[1]]
if (length(tokens) == 10)
return(NULL) #discard these observations. They do not help us
tmp = matrix(tokens[ - (1:10) ], ncol = 4, byrow = TRUE)
cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow(tmp), ncol = 6, byrow = TRUE), tmp) }
lines = txt[ substr(txt, 1, 1) != "#" ]
tmp = lapply(lines, processLine)
#################
#options(error = recover, warn = 1)
#################
tmp = lapply(lines, processLine)
offline = as.data.frame(do.call("rbind", tmp), stringsAsFactors = FALSE)
names(offline) = c("time", "scanMac", "posX", "posY", "posZ", "orientation",
"mac", "signal", "channel", "type")
numVars = c("time", "posX", "posY", "posZ", "orientation", "signal")
offline[ numVars ] = lapply(offline[ numVars ], as.numeric)
#drop all records for adhoc measurements, remove the type variable and apply names
offline = offline[ offline$type == "3", ]
offline = offline[ , "type" != names(offline) ]
# create time variables
offline$rawTime = offline$time
offline$time = offline$time/1000
class(offline$time) = c("POSIXt", "POSIXct")
unlist(lapply(offline, class))
# eliminate unused variables
#summary(sapply(offline[ , c("mac", "channel", "scanMac")], as.factor))
offline = offline[ , !(names(offline) %in% c("scanMac", "posZ"))]
#Round angles to nearest 8th 45 degree direction
roundOrientation = function(angles) {
refs = seq(0, by = 45, length = 9)
q = sapply(angles, function(o) which.min(abs(o - refs)))
c(refs[1:8], 0)[q]
}
offline$angle = roundOrientation(offline$orientation)
with(offline, boxplot(orientation ~ angle, xlab = "nearest 45 degree angle",
ylab="orientation"))
#############################################################################
#############################################################################
#############################################################################
#there is a discrepancy with the documentation.
# keep the records from the top 7 devices
subMacs = names(sort(table(offline$mac), decreasing = TRUE))[1:7]
offline = offline[ offline$mac %in% subMacs, ]
macChannel = with(offline, table(mac, channel))
apply(macChannel, 1, function(x) sum(x > 0))
#Indeed we see that there is a one-to-one correspondence between MAC address
#and channel for these 7 devices. This means we can eliminate channel from
#offline
offline = offline[ , "channel" != names(offline)]
#############################################################################
#############################################################################
#############################################################################
locDF = with(offline,
by(offline, list(posX, posY), function(x) x))
#The null values correspond to the combinations of the xs and ys that were
#not observed. We drop these unneeded elements
locDF = locDF[ !sapply(locDF, is.null) ]
locCounts = sapply(locDF, nrow)
# if we want to keep the position information with the location
locCounts = sapply(locDF,
function(df)
c(df[1, c("posX", "posY")], count = nrow(df)))
offline$posXY = paste(offline$posX, offline$posY, sep = "-")
byLocAngleAP = with(offline, by(offline, list(posXY, angle, mac), function(x) x))
signalSummary =
lapply(byLocAngleAP,
function(oneLoc) {
ans = oneLoc[1, ]
ans$medSignal = median(oneLoc$signal)
ans$avgSignal = mean(oneLoc$signal)
ans$num = length(oneLoc$signal)
ans$sdSignal = sd(oneLoc$signal)
ans$iqrSignal = IQR(oneLoc$signal)
ans
})
offlineSummary = do.call("rbind", signalSummary)
###########################Analysis##########################################
locCounts = t(locCounts)
plot(locCounts, type = "n", xlab = "", ylab = "")
text(locCounts, labels = locCounts[,3], cex = .8, srt = 45)
bwplot(signal ~ factor(angle) | mac, data = offline,
subset = posX == 2 & posY == 12
#& mac != "00:0f:a3:39:dd:cd",
& mac != "00:0f:a3:39:e1:c0",
layout = c(2,3))
summary(offline$signal)
densityplot( ~ signal | mac + factor(angle), data = offline, subset = posX == 24 & posY == 4 , bw = 0.5, plot.points = FALSE)
#Make boxplots of sdSignal for subgroups of avgSignal by
#turning avgSignal into a categorical variable
#We see in Figure below that the weakest signals have small standard deviations and that it appears that the SD increases with the average signal strength. If we plan to model the behavior of signal strength, then we want to take these features into consideration.
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac != "00:0f:a3:39:dd:cd",
xlab = "Mean Signal without cd ", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac !="00:0f:a3:39:e1:c0",
xlab = "Mean Signal without c0", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
xlab = "Mean Signal Keep co and cd ", ylab = "SD Signal")
#Examine the skewness of signal strength by plotting the diﬀerence, avgSignal - medSignal, against the number of observations. We also add a local average of the diﬀerence between the mean and median to better help us assess its size.
with(offlineSummary,
smoothScatter((avgSignal - medSignal) ~ num,
xlab = "Number of Observations",
ylab = "mean - median"))
abline(h = 0, col = "#984ea3", lwd = 2)
#We use loess to locally smooth the diﬀerences betweenthe mean and median
lo.obj =
with(offlineSummary,
loess(diff ~ num,
data = data.frame(diff = (avgSignal - medSignal),
num = num)))
#Then we use the ﬁtted model to predict the diﬀerence for each value of num
#and add these predictions to the scatter plot
lo.obj.pr = predict(lo.obj, newdata = data.frame(num = (70:120)))
lines(x = 70:120, y = lo.obj.pr, col = "#4daf4a", lwd = 2)
oneAPAngle = subset(offline, mac == subMacs[5] & angle == 0)
oneAPAngle = subset(offlineSummary, mac == subMacs[5] & angle == 0)
surfaceSS = function(data, mac, angle = 45) {
require(fields)
oneAPAngle = data[ data$mac == mac & data$angle == angle, ]
smoothSS = Tps(oneAPAngle[, c("posX","posY")],
oneAPAngle$avgSignal)
vizSmooth = predictSurface(smoothSS)
plot.surface(vizSmooth, type = "C",
xlab = "", ylab = "", xaxt = "n", yaxt = "n")
points(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5)
}
mapply(surfaceSS, mac = subMacs[ rep(c(5, 1), each = 2) ],
angle = rep(c(0, 135), 2),
data = list(data = offlineSummary))
parCur = par(mfrow = c(2,2), mar = rep(1, 4))
par(parCur)
View(offlineSummary)
View(offlineSummary)
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs[ -2 ], c("x", "y") ))
View(AP)
View(offlineSummary)
library(fields)
library(lattice)
##################Data Processing###################
setwd('C:/Users/danie/Documents/GitHub/Quantifying-The-World/Case Study 1')
txt = readLines("offline.final.trace.txt")
processLine =
function(x)
{
tokens = strsplit(x, "[;=,]")[[1]]
if (length(tokens) == 10)
return(NULL) #discard these observations. They do not help us
tmp = matrix(tokens[ - (1:10) ], ncol = 4, byrow = TRUE)
cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow(tmp), ncol = 6, byrow = TRUE), tmp) }
lines = txt[ substr(txt, 1, 1) != "#" ]
tmp = lapply(lines, processLine)
#################
#options(error = recover, warn = 1)
#################
tmp = lapply(lines, processLine)
offline = as.data.frame(do.call("rbind", tmp), stringsAsFactors = FALSE)
names(offline) = c("time", "scanMac", "posX", "posY", "posZ", "orientation",
"mac", "signal", "channel", "type")
numVars = c("time", "posX", "posY", "posZ", "orientation", "signal")
offline[ numVars ] = lapply(offline[ numVars ], as.numeric)
#drop all records for adhoc measurements, remove the type variable and apply names
offline = offline[ offline$type == "3", ]
offline = offline[ , "type" != names(offline) ]
# create time variables
offline$rawTime = offline$time
offline$time = offline$time/1000
class(offline$time) = c("POSIXt", "POSIXct")
unlist(lapply(offline, class))
# eliminate unused variables
#summary(sapply(offline[ , c("mac", "channel", "scanMac")], as.factor))
offline = offline[ , !(names(offline) %in% c("scanMac", "posZ"))]
#Round angles to nearest 8th 45 degree direction
roundOrientation = function(angles) {
refs = seq(0, by = 45, length = 9)
q = sapply(angles, function(o) which.min(abs(o - refs)))
c(refs[1:8], 0)[q]
}
offline$angle = roundOrientation(offline$orientation)
with(offline, boxplot(orientation ~ angle, xlab = "nearest 45 degree angle",
ylab="orientation"))
#############################################################################
#############################################################################
#############################################################################
#there is a discrepancy with the documentation.
# keep the records from the top 7 devices
subMacs = names(sort(table(offline$mac), decreasing = TRUE))[1:7]
offline = offline[ offline$mac %in% subMacs, ]
macChannel = with(offline, table(mac, channel))
apply(macChannel, 1, function(x) sum(x > 0))
#Indeed we see that there is a one-to-one correspondence between MAC address
#and channel for these 7 devices. This means we can eliminate channel from
#offline
offline = offline[ , "channel" != names(offline)]
#############################################################################
#############################################################################
#############################################################################
locDF = with(offline,
by(offline, list(posX, posY), function(x) x))
#The null values correspond to the combinations of the xs and ys that were
#not observed. We drop these unneeded elements
locDF = locDF[ !sapply(locDF, is.null) ]
locCounts = sapply(locDF, nrow)
# if we want to keep the position information with the location
locCounts = sapply(locDF,
function(df)
c(df[1, c("posX", "posY")], count = nrow(df)))
offline$posXY = paste(offline$posX, offline$posY, sep = "-")
byLocAngleAP = with(offline, by(offline, list(posXY, angle, mac), function(x) x))
signalSummary =
lapply(byLocAngleAP,
function(oneLoc) {
ans = oneLoc[1, ]
ans$medSignal = median(oneLoc$signal)
ans$avgSignal = mean(oneLoc$signal)
ans$num = length(oneLoc$signal)
ans$sdSignal = sd(oneLoc$signal)
ans$iqrSignal = IQR(oneLoc$signal)
ans
})
offlineSummary = do.call("rbind", signalSummary)
###########################Analysis##########################################
locCounts = t(locCounts)
plot(locCounts, type = "n", xlab = "", ylab = "")
text(locCounts, labels = locCounts[,3], cex = .8, srt = 45)
bwplot(signal ~ factor(angle) | mac, data = offline,
subset = posX == 2 & posY == 12
#& mac != "00:0f:a3:39:dd:cd",
& mac != "00:0f:a3:39:e1:c0",
layout = c(2,3))
summary(offline$signal)
densityplot( ~ signal | mac + factor(angle), data = offline, subset = posX == 24 & posY == 4 , bw = 0.5, plot.points = FALSE)
#Make boxplots of sdSignal for subgroups of avgSignal by
#turning avgSignal into a categorical variable
#We see in Figure below that the weakest signals have small standard deviations and that it appears that the SD increases with the average signal strength. If we plan to model the behavior of signal strength, then we want to take these features into consideration.
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac != "00:0f:a3:39:dd:cd",
xlab = "Mean Signal without cd ", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac !="00:0f:a3:39:e1:c0",
xlab = "Mean Signal without c0", ylab = "SD Signal")
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
xlab = "Mean Signal Keep co and cd ", ylab = "SD Signal")
#Examine the skewness of signal strength by plotting the diﬀerence, avgSignal - medSignal, against the number of observations. We also add a local average of the diﬀerence between the mean and median to better help us assess its size.
with(offlineSummary,
smoothScatter((avgSignal - medSignal) ~ num,
xlab = "Number of Observations",
ylab = "mean - median"))
abline(h = 0, col = "#984ea3", lwd = 2)
#We use loess to locally smooth the diﬀerences betweenthe mean and median
lo.obj =
with(offlineSummary,
loess(diff ~ num,
data = data.frame(diff = (avgSignal - medSignal),
num = num)))
#Then we use the ﬁtted model to predict the diﬀerence for each value of num
#and add these predictions to the scatter plot
lo.obj.pr = predict(lo.obj, newdata = data.frame(num = (70:120)))
lines(x = 70:120, y = lo.obj.pr, col = "#4daf4a", lwd = 2)
oneAPAngle = subset(offline, mac == subMacs[5] & angle == 0)
oneAPAngle = subset(offlineSummary, mac == subMacs[5] & angle == 0)
surfaceSS = function(data, mac, angle = 45) {
require(fields)
oneAPAngle = data[ data$mac == mac & data$angle == angle, ]
smoothSS = Tps(oneAPAngle[, c("posX","posY")],
oneAPAngle$avgSignal)
vizSmooth = predictSurface(smoothSS)
plot.surface(vizSmooth, type = "C",
xlab = "", ylab = "", xaxt = "n", yaxt = "n")
points(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5)
}
mapply(surfaceSS, mac = subMacs[ rep(c(5, 1), each = 2) ],
angle = rep(c(0, 135), 2),
data = list(data = offlineSummary))
parCur = par(mfrow = c(2,2), mar = rep(1, 4))
par(parCur)
############################################################################################################
############################################################################################################
############################################################################################################
#We ﬁnd that two MAC addresses have similar heat maps and these both
#correspond to the access point near the center of the building (i.e., x =7.5 and y =6.3).
#We choose the ﬁrst of these and leave as an exercise the analysis of the impact of this
#decision on predicting location.
#remove cd
#offlineSummary = subset(offlineSummary, mac != subMacs[2])
#remove co
#offlineSummary = subset(offlineSummary, mac != subMacs[1])
#keep all (dont run above subsets to keep all)
############################################################################################################
############################################################################################################
############################################################################################################
subMacs
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs, c("x", "y") ))
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs[ -2 ], c("x", "y") ))
View(AP)
View(AP)
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs[], c("x", "y") ))
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs[0], c("x", "y") ))
View(AP)
View(AP)
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs[-2], c("x", "y") ))
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs[-3], c("x", "y") ))
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs[-9], c("x", "y") ))
