rmseMin = min(err)
kMin = which(err == rmseMin)[1]
segments(x0 = 0, x1 = kMin, y0 = rmseMin, col = gray(0.4),
lty = 2, lwd = 2)
segments(x0 = kMin, x1 = kMin, y0 = 1100,  y1 = rmseMin,
col = grey(0.4), lty = 2, lwd = 2)
#mtext(kMin, side = 1, line = 1, at = kMin, col = grey(0.4))
text(x = kMin - 2, y = rmseMin + 40,
label = as.character(round(rmseMin)), col = grey(0.4))
estXYk5 = predXY(newSignals = onlineSummary[ , 6:11],
newAngles = onlineSummary[ , 4],
offlineSummary, numAngles = 1, k = 5)
calcError(estXYk5, actualXY)
onlineFold = subset(onlineCVSummary,
posXY %in% permuteLocs[ , 1])
offlineFold = subset(offlineSummary,
posXY %in% permuteLocs[ , -1])
estFold = predXY(newSignals = onlineFold[ , 6:11],
newAngles = onlineFold[ , 4],
offlineFold, numAngles = 3, k = 3)
actualFold = onlineFold[ , c("posX", "posY")]
calcError(estFold, actualFold)
K = 20
err = rep(0, K)
for (j in 1:v) {
onlineFold = subset(onlineCVSummary,
posXY %in% permuteLocs[ , j])
offlineFold = subset(offlineSummary,
posXY %in% permuteLocs[ , -j])
actualFold = onlineFold[ , c("posX", "posY")]
for (k in 1:K) {
estFold = predXY(newSignals = onlineFold[ , 6:11],
newAngles = onlineFold[ , 4],
offlineFold, numAngles = 1, k = k)
err[k] = err[k] + calcError(estFold, actualFold)
}
}
View(actualFold)
View(actualXY)
View(AP)
#set working directory
setwd('C:/Users/danie/Documents/GitHub/Quantifying-The-World/Case Study 1')
#Load Data
txt = readLines("offline.final.trace.txt")
processLine =
function(x)
{
tokens = strsplit(x, "[;=,]")[[1]]
if (length(tokens) == 10) return(NULL) #discard these observations. they do not help us
tmp = matrix(tokens[ - (1:10) ], , 4, byrow = TRUE)
cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow(tmp), 6, byrow = TRUE), tmp) }
lines = txt[ substr(txt, 1, 1) != "#" ]
tmp = lapply(lines, processLine)
options(error = recover, warn = 1)
tmp = lapply(lines, processLine)
offline = as.data.frame(do.call("rbind", tmp), stringsAsFactors = FALSE)
names(offline) = c("time", "scanMac", "posX", "posY", "posZ", "orientation",
"mac", "signal", "channel", "type")
numVars = c("time", "posX", "posY", "posZ", "orientation", "signal")
offline[ numVars ] = lapply(offline[ numVars ], as.numeric)
#drop all records for adhoc measurements and remove the type variable
offline = offline[ offline$type == "3", ]
offline = offline[ , "type" != names(offline) ]
dim(offline)
offline$rawTime = offline$time
offline$time = offline$time/1000
class(offline$time) = c("POSIXt", "POSIXct")
#check datatypes
#unlist(lapply(offline, class))
#check to see if data are reasonable
summary(offline[, numVars])
#convert the character variables to factors
#remove the posZ variable and examine them
summary(sapply(offline[ , c("mac", "channel", "scanMac")], as.factor))
offline = offline[ , !(names(offline) %in% c("scanMac", "posZ"))]
length(unique(offline$orientation))
plot(ecdf(offline$orientation))
roundOrientation = function(angles) {
refs = seq(0, by = 45, length = 9)
q = sapply(angles, function(o) which.min(abs(o - refs)))
c(refs[1:8], 0)[q]
}
offline$angle = roundOrientation(offline$orientation)
with(offline, boxplot(orientation ~ angle, xlab = "nearest 45 degree angle",
ylab="orientation"))
#check to see if there is a 1 - relationship betweeen mac and channel
table(offline$mac)
#there is a discrepancy with the documentation.
# keep the records from the top 7 devices
subMacs = names(sort(table(offline$mac), decreasing = TRUE))[1:7]
offline = offline[ offline$mac %in% subMacs, ]
macChannel = with(offline, table(mac, channel))
apply(macChannel, 1, function(x) sum(x > 0))
#Indeed we see that there is a one-to-one correspondence between MAC address
#and channel for these 7 devices. This means we can eliminate channel from
#offline
offline = offline[ , "channel" != names(offline)]
locDF = with(offline,
by(offline, list(posX, posY), function(x) x))
length(locDF)
sum(sapply(locDF, is.null))
#The null values correspond to the combinations of the xs and ys that were
#not observed. We drop these unneeded elements
locDF = locDF[ !sapply(locDF, is.null) ]
length(locDF)
locCounts = sapply(locDF, nrow)
# if we want to keep the position information with the location
locCounts = sapply(locDF,
function(df)
c(df[1, c("posX", "posY")], count = nrow(df)))
locCounts[ , 1:8]
#there are roughly the same number of signals detected
#at each location.
locCounts = t(locCounts)
plot(locCounts, type = "n", xlab = "", ylab = "")
text(locCounts, labels = locCounts[,3], cex = .8, srt = 45)
#checking distributions
library(lattice)
bwplot(signal ~ factor(angle) | mac, data = offline,
subset = posX == 2 & posY == 12
& mac != "00:0f:a3:39:dd:cd",
layout = c(2,3))
summary(offline$signal)
densityplot( ~ signal | mac + factor(angle), data = offline, subset = posX == 24 & posY == 4 & mac != "00:0f:a3:39:dd:cd", bw = 0.5, plot.points = FALSE)
offline$posXY = paste(offline$posX, offline$posY, sep = "-")
byLocAngleAP = with(offline, by(offline, list(posXY, angle, mac), function(x) x))
signalSummary =
lapply(byLocAngleAP,
function(oneLoc) {
ans = oneLoc[1, ]
ans$medSignal = median(oneLoc$signal)
ans$avgSignal = mean(oneLoc$signal)
ans$num = length(oneLoc$signal)
ans$sdSignal = sd(oneLoc$signal)
ans$iqrSignal = IQR(oneLoc$signal)
ans
})
offlineSummary = do.call("rbind", signalSummary)
#Make boxplots of sdSignal for subgroups of avgSignal by
#turning avgSignal into a categorical variable
breaks = seq(-90, -30, by = 5)
bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
data = offlineSummary,
subset = mac != "00:0f:a3:39:dd:cd",
xlab = "Mean Signal", ylab = "SD Signal")
with(offlineSummary,
smoothScatter((avgSignal - medSignal) ~ num,
xlab = "Number of Observations",
ylab = "mean - median"))
abline(h = 0, col = "#984ea3", lwd = 2)
#We use loess to locally smooth the diﬀerences betweenthe mean and median
lo.obj =
with(offlineSummary,
loess(diff ~ num,
data = data.frame(diff = (avgSignal - medSignal),
num = num)))
#Then we use the ﬁtted model to predict the diﬀerence for each value of num
#and add these predictions to the scatter plot
lo.obj.pr = predict(lo.obj, newdata = data.frame(num = (70:120)))
lines(x = 70:120, y = lo.obj.pr, col = "#4daf4a", lwd = 2)
oneAPAngle = subset(offline, mac == subMacs[5] & angle == 0)
oneAPAngle = subset(offlineSummary, mac == subMacs[5] & angle == 0)
library(fields)
smoothSS = Tps(oneAPAngle[, c("posX","posY")], oneAPAngle$avgSignal)
vizSmooth = predictSurface(smoothSS)
plot.surface(vizSmooth, type = "C")
points(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5)
parCur = par(mfrow = c(2,2), mar = rep(1, 4))
surfaceSS = function(data, mac, angle = 45) {
require(fields)
oneAPAngle = data[ data$mac == mac & data$angle == angle, ]
smoothSS = Tps(oneAPAngle[, c("posX","posY")],
oneAPAngle$avgSignal)
vizSmooth = predictSurface(smoothSS)
plot.surface(vizSmooth, type = "C",
xlab = "", ylab = "", xaxt = "n", yaxt = "n")
points(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5)
}
mapply(surfaceSS, mac = subMacs[ rep(c(5, 1), each = 2) ],
angle = rep(c(0, 135), 2),
data = list(data = offlineSummary))
par(parCur)
offlineSummary = subset(offlineSummary, mac != subMacs[2])
#We create a small matrix with the relevant positions for the 6 access
#points on the ﬂoor plan with
AP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
1, 14, 33.5, 9.3, 33.5, 2.8),
ncol = 2, byrow = TRUE,
dimnames = list(subMacs[ -2 ], c("x", "y") ))
#note that Row names ar emac addresses:
AP
diffs = offlineSummary[ , c("posX", "posY")] -
AP[ offlineSummary$mac, ]
#find euclidean distance
offlineSummary$dist = sqrt(diffs[ , 1]^2 + diffs[ , 2]^2)
xyplot(signal ~ dist | factor(mac) + factor(angle),
data = offlineSummary, pch = 19, cex = 0.3,
xlab ="distance")
readData =
function(filename = 'offline.final.trace.txt',
subMacs = c("00:0f:a3:39:e1:c0", "00:0f:a3:39:dd:cd", "00:14:bf:b1:97:8a",
"00:14:bf:3b:c7:c6", "00:14:bf:b1:97:90", "00:14:bf:b1:97:8d",
"00:14:bf:b1:97:81"))
{
txt = readLines(filename)
lines = txt[ substr(txt, 1, 1) != "#" ]
tmp = lapply(lines, processLine)
offline = as.data.frame(do.call("rbind", tmp),
stringsAsFactors= FALSE)
names(offline) = c("time", "scanMac",
"posX", "posY", "posZ", "orientation",
"mac", "signal", "channel", "type")
# keep only signals from access points
offline = offline[ offline$type == "3", ]
# drop scanMac, posZ, channel, and type - no info in them
dropVars = c("scanMac", "posZ", "channel", "type")
offline = offline[ , !( names(offline) %in% dropVars ) ]
# drop more unwanted access points
offline = offline[ offline$mac %in% subMacs, ]
# convert numeric values
numVars = c("time", "posX", "posY", "orientation", "signal")
offline[ numVars ] = lapply(offline[ numVars ], as.numeric)
# convert time to POSIX
offline$rawTime = offline$time
offline$time = offline$time/1000
class(offline$time) = c("POSIXt", "POSIXct")
# round orientations to nearest 45
offline$angle = roundOrientation(offline$orientation)
return(offline)
}
macs = unique(offlineSummary$mac)
online = readData("online.final.trace.txt", subMacs = macs)
online$posXY = paste(online$posX, online$posY, sep = "-")
length(unique(online$posXY))
tabonlineXYA = table(online$posXY, online$angle)
tabonlineXYA[1:6, ]
keepVars = c("posXY", "posX","posY", "orientation", "angle")
byLoc = with(online,
by(online, list(posXY),
function(x) {
ans = x[1, keepVars]
avgSS = tapply(x$signal, x$mac, mean)
y = matrix(avgSS, nrow = 1, ncol = 6,
dimnames = list(ans$posXY, names(avgSS)))
cbind(ans, y)
}))
onlineSummary = do.call("rbind", byLoc)
#for m the number of angles and angleNewObs the angle of the new
#observation, we ﬁnd the angles to include from our training data as follows:
dim(onlineSummary)
names(onlineSummary)
m = 3; angleNewObs = 230
refs = seq(0, by = 45, length  = 8)
nearestAngle = roundOrientation(angleNewObs)
if (m %% 2 == 1) {
angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
} else {
m = m + 1
angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
if (sign(angleNewObs - nearestAngle) > -1)
angles = angles[ -1 ]
else
angles = angles[ -m ]
}
#Notice that we handle the case of m odd and even separately. Also, we must
#map the angles to values in refs, e.g., -45 maps to 335 and 405 maps to 45,
#so we adjust angles with
angles = angles + nearestAngle
angles[angles < 0] = angles[ angles < 0 ] + 360
angles[angles > 360] = angles[ angles > 360 ] - 360
#After we have the subset of the desired angles, we select the observations
#from offlineSummary to analyze with
offlineSubset =
offlineSummary[ offlineSummary$angle %in% angles, ]
#Then we aggregate the signal strengths from these angles and create a data
#structure that is similar to that of onlineSummary. Rather than repeat the
#code again, we turn these computations into a helper function, which we
#call reshapeSS():
reshapeSS = function(data, varSignal = "signal",
keepVars = c("posXY", "posX","posY")) {
byLocation =
with(data, by(data, list(posXY),
function(x) {
ans = x[1, keepVars]
avgSS = tapply(x[ , varSignal ], x$mac, mean)
y = matrix(avgSS, nrow = 1, ncol = 6,
dimnames = list(ans$posXY,
names(avgSS)))
cbind(ans, y)
}))
newDataSS = do.call("rbind", byLocation)
return(newDataSS)
}
#summarize and reshape offlineSubset:
trainSS = reshapeSS(offlineSubset, varSignal = "avgSignal")
#create function selectTrain()
selectTrain = function(angleNewObs, signals = NULL, m = 1){
# m is the number of angles to keep between 1 and 5
refs = seq(0, by = 45, length  = 8)
nearestAngle = roundOrientation(angleNewObs)
if (m %% 2 == 1)
angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
else {
m = m + 1
angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
if (sign(angleNewObs - nearestAngle) > -1)
angles = angles[ -1 ]
else
angles = angles[ -m ]
}
angles = angles + nearestAngle
angles[angles < 0] = angles[ angles < 0 ] + 360
angles[angles > 360] = angles[ angles > 360 ] - 360
angles = sort(angles)
offlineSubset = signals[ signals$angle %in% angles, ]
reshapeSS(offlineSubset, varSignal = "avgSignal")
}
train130 = selectTrain(130, offlineSummary, m = 3)
head(train130)
length(train130[[1]])
findNN = function(newSignal, trainSubset) {
diffs = apply(trainSubset[ , 4:9], 1,
function(x) x - newSignal)
dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) )
closest = order(dists)
return(trainSubset[closest, 1:3 ])
}
# predict X-Y based on the the neasest k neighbors (default 3)
predXY = function(newSignals, newAngles, trainData,
numAngles = 1, k = 3){
closeXY = list(length = nrow(newSignals))
for (i in 1:nrow(newSignals)) {
trainSS = selectTrain(newAngles[i], trainData, m = numAngles)
closeXY[[i]] =
findNN(newSignal = as.numeric(newSignals[i, ]), trainSS)
}
estXY = lapply(closeXY,
function(x) sapply(x[ , 2:3],
function(x) mean(x[1:k])))
estXY = do.call("rbind", estXY)
return(estXY)
}
# nearest 3 neighbors
estXYk3 = predXY(newSignals = onlineSummary[ , 6:11],
newAngles = onlineSummary[ , 4],
offlineSummary, numAngles = 3, k = 3)
# nearest neighbor
estXYk1 = predXY(newSignals = onlineSummary[ , 6:11],
newAngles = onlineSummary[ , 4],
offlineSummary, numAngles = 3, k = 1)
# predict and map errors
floorErrorMap = function(estXY, actualXY, trainPoints = NULL, AP = NULL){
plot(0, 0, xlim = c(0, 35), ylim = c(-3, 15), type = "n",
xlab = "", ylab = "", axes = FALSE)
box()
if ( !is.null(AP) ) points(AP, pch = 15)
if ( !is.null(trainPoints) )
points(trainPoints, pch = 19, col="grey", cex = 0.6)
points(x = actualXY[, 1], y = actualXY[, 2],
pch = 19, cex = 0.8 )
points(x = estXY[, 1], y = estXY[, 2],
pch = 8, cex = 0.8 )
segments(x0 = estXY[, 1], y0 = estXY[, 2],
x1 = actualXY[, 1], y1 = actualXY[ , 2],
lwd = 2, col = "red")
}
trainPoints = offlineSummary[ offlineSummary$angle == 0 &
offlineSummary$mac == "00:0f:a3:39:e1:c0" ,
c("posX", "posY")]
# 3 NN
floorErrorMap(estXYk3, onlineSummary[ , c("posX","posY")],
trainPoints = trainPoints, AP = AP)
# 1 NN
floorErrorMap(estXYk1, onlineSummary[ , c("posX","posY")],
trainPoints = trainPoints, AP = AP)
##Calculate Error
options(error = recover, warn = 1)
calcError =
function(estXY, actualXY)
sum( rowSums( (estXY - actualXY)^2) )
actualXY = onlineSummary[ , c("posX", "posY")]
sapply(list(estXYk1, estXYk3), calcError, actualXY)
v = 11
permuteLocs = sample(unique(offlineSummary$posXY))
permuteLocs = matrix(permuteLocs, ncol = v,
nrow = floor(length(permuteLocs)/v))
onlineFold = subset(offlineSummary, posXY %in% permuteLocs[ , 1])
reshapeSS = function(data, varSignal = "signal",
keepVars = c("posXY", "posX","posY"),
sampleAngle = FALSE,
refs = seq(0, 315, by = 45)) {
byLocation =
with(data, by(data, list(posXY),
function(x) {
if (sampleAngle) {
x = x[x$angle == sample(refs, size = 1), ]}
ans = x[1, keepVars]
avgSS = tapply(x[ , varSignal ], x$mac, mean)
y = matrix(avgSS, nrow = 1, ncol = 6,
dimnames = list(ans$posXY,
names(avgSS)))
cbind(ans, y)
}))
newDataSS = do.call("rbind", byLocation)
return(newDataSS)
}
# up to 20 neighbors, 11 folds
# this one can run for a while (5-10 mins)
# this cell and the next are the same, but the angles change slightly!!
offline = offline[ offline$mac != "00:0f:a3:39:dd:cd", ]
keepVars = c("posXY", "posX","posY", "orientation", "angle")
onlineCVSummary = reshapeSS(offline, keepVars = keepVars,
sampleAngle = TRUE)
onlineFold = subset(onlineCVSummary,
posXY %in% permuteLocs[ , 1])
offlineFold = subset(offlineSummary,
posXY %in% permuteLocs[ , -1])
estFold = predXY(newSignals = onlineFold[ , 6:11],
newAngles = onlineFold[ , 4],
offlineFold, numAngles = 1, k = 3)
actualFold = onlineFold[ , c("posX", "posY")]
calcError(estFold, actualFold)
K = 20
err = rep(0, K)
for (j in 1:v) {
onlineFold = subset(onlineCVSummary,
posXY %in% permuteLocs[ , j])
offlineFold = subset(offlineSummary,
posXY %in% permuteLocs[ , -j])
actualFold = onlineFold[ , c("posX", "posY")]
for (k in 1:K) {
estFold = predXY(newSignals = onlineFold[ , 6:11],
newAngles = onlineFold[ , 4],
offlineFold, numAngles = 1, k = k)
err[k] = err[k] + calcError(estFold, actualFold)
}
}
plot(y = err, x = (1:K),  type = "l", lwd= 2,
ylim = c(800, 2100),
xlab = "Number of Neighbors",
ylab = "Sum of Square Errors")
rmseMin = min(err)
kMin = which(err == rmseMin)[1]
segments(x0 = 0, x1 = kMin, y0 = rmseMin, col = gray(0.4),
lty = 2, lwd = 2)
segments(x0 = kMin, x1 = kMin, y0 = 1100,  y1 = rmseMin,
col = grey(0.4), lty = 2, lwd = 2)
#mtext(kMin, side = 1, line = 1, at = kMin, col = grey(0.4))
text(x = kMin - 2, y = rmseMin + 40,
label = as.character(round(rmseMin)), col = grey(0.4))
estXYk5 = predXY(newSignals = onlineSummary[ , 6:11],
newAngles = onlineSummary[ , 4],
offlineSummary, numAngles = 1, k = 5)
calcError(estXYk5, actualXY)
######
onlineFold = subset(onlineCVSummary,
posXY %in% permuteLocs[ , 1])
offlineFold = subset(offlineSummary,
posXY %in% permuteLocs[ , -1])
estFold = predXY(newSignals = onlineFold[ , 6:11],
newAngles = onlineFold[ , 4],
offlineFold, numAngles = 3, k = 3)
actualFold = onlineFold[ , c("posX", "posY")]
calcError(estFold, actualFold)
K = 20
err = rep(0, K)
for (j in 1:v) {
onlineFold = subset(onlineCVSummary,
posXY %in% permuteLocs[ , j])
offlineFold = subset(offlineSummary,
posXY %in% permuteLocs[ , -j])
actualFold = onlineFold[ , c("posX", "posY")]
for (k in 1:K) {
estFold = predXY(newSignals = onlineFold[ , 6:11],
newAngles = onlineFold[ , 4],
offlineFold, numAngles = 1, k = k)
err[k] = err[k] + calcError(estFold, actualFold)
}
}
plot(y = err, x = (1:K),  type = "l", lwd= 2,
ylim = c(1200, 2100),
xlab = "Number of Neighbors",
ylab = "Sum of Square Errors")
rmseMin = min(err)
kMin = which(err == rmseMin)[1]
segments(x0 = 0, x1 = kMin, y0 = rmseMin, col = gray(0.4),
lty = 2, lwd = 2)
segments(x0 = kMin, x1 = kMin, y0 = 1100,  y1 = rmseMin,
col = grey(0.4), lty = 2, lwd = 2)
#mtext(kMin, side = 1, line = 1, at = kMin, col = grey(0.4))
text(x = kMin - 2, y = rmseMin + 40,
label = as.character(round(rmseMin)), col = grey(0.4))
estXYk5 = predXY(newSignals = onlineSummary[ , 6:11],
newAngles = onlineSummary[ , 4],
offlineSummary, numAngles = 3, k = 5)
calcError(estXYk5, actualXY)
print(calcError(estXYk5, actualXY))
######
predXY2 = function(newSignals, newAngles, trainData,
numAngles = 1, k = 3){
closeXY = list(length = nrow(newSignals))
for (i in 1:nrow(newSignals)) {
trainSS = selectTrain(newAngles[i], trainData, m = numAngles)
closeXY[[i]] = findNN(newSignal = as.numeric(newSignals[i, ]),
trainSS)
}
estXY = lapply(closeXY, function(x)
sapply(x[ , 2:3],
function(x) mean(x[1:k])))
estXY = do.call("rbind", estXY)
return(estXY)
}
